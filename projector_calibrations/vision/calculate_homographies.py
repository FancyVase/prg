import numpy as np
import cv2

def get_transformation(src, des):
	src = np.float32(src)
	des = np.float32(des)
	return cv2.findHomography(src, des)[0]

def calculate_homographies(matches):
	if matches is None:
		matches = [[[[519, 390], [208, 464], [595, 421], [219, 625], [459, 419], [248, 269], [351, 263], [409, 433], [475, 344], [808, 374], [339, 466], [630, 334], [821, 460], [595, 646], [531, 583], [251, 548], [291, 518], [810, 388], [315, 355], [630, 619]], [[176.7994502395336, 182.24762526742384], [205.6115701791838, 324.0838461896816], [193.38609981797845, 149.25473683573753], [284.80282739582844, 323.82413424246954], [189.24522051568246, 209.77017767273318], [113.27105444108575, 299.74248894032905], [113.28354991627748, 253.52983224521142], [194.7823392528702, 232.29994207934928], [153.94634612931466, 200.7478249948259], [176.0540751824831, 55.52787077024838], [209.4193278539234, 264.4667128665931], [152.86176377582635, 132.34937914603015], [216.36533175387413, 50.98359701919791], [301.6333587207303, 154.13210642805853], [269.53450911773024, 181.11598554931575], [247.50059401443858, 306.89676137154123], [233.66927685091778, 287.6950728256476], [182.44704464045012, 54.97314346077707], [155.6643488843097, 272.45358665769373], [289.21439967917723, 138.11951821105296]]], [[[1149, 316], [1828, 415], [1558, 185], [1796, 168], [1646, 186], [1289, 470], [1535, 403], [1241, 469], [1663, 534], [1296, 420], [1663, 348], [1435, 495], [1879, 124], [1271, 115], [1831, 344], [1300, 571], [1136, 119], [1324, 317], [1525, 314], [1584, 395]], [[469.5785053103689, 364.6657465097328], [521.0456519968831, 73.49408563914231], [420.1370290970354, 182.37868522570048], [415.666550001798, 75.5084757264429], [421.71913640403153, 142.99516225335876], [536.4264199292577, 305.16802632287084], [512.551273782903, 198.4974109115044], [535.3394075909192, 325.67139163600433], [567.5038559779808, 148.51896852136937], [515.8783718267965, 301.80549201125547], [491.512658566923, 141.58166724981012], [548.8323825332263, 243.61674909155417], [397.62474109463955, 36.55219987675722], [384.08209206358964, 309.0493381726295], [491.83958357604155, 68.88425919864598], [576.795202181403, 301.5865155069748], [383.5937190865186, 369.87079762996126], [473.297571157294, 288.0916254708804], [474.9986239127904, 200.61508142107377], [510.04372729608775, 177.584228449658]]], [[[2467, 574], [2303, 314], [2369, 269], [2292, 554], [2667, 383], [2788, 285], [2388, 520], [2653, 217], [2473, 472], [2223, 190], [2334, 530], [2338, 364], [2814, 498], [2251, 501], [2707, 433]], [[328.588513305273, 257.4441904173759], [268.90534773603423, 106.10334765750815], [303.15043648774423, 89.01250681525846], [238.28714164583334, 236.39563334291674], [432.99743353536905, 161.2477569190493], [485.92896319366645, 121.13447406814457], [292.17723362717146, 220.76248480747412], [429.934664262503, 83.20647594355275], [338.38513280891004, 197.94888419593755], [243.4177314194186, 44.553045076738236], [263.3098222493283, 224.04829000867286], [281.02408151660273, 133.02701868388777], [499.6956810179372, 229.88658182362622], [222.79681423694657, 202.41039529825358], [450.7130972065025, 189.076895021122]]]]
		

	# Here, projector 2 is acting as the master projector
	# change according to your projector setup

	rectangle_world = [[0, 50.7], [81.4, 50.7], [81.4, 0], [0, 0]]
	rectangle_projector = [[1052, 455], [1467, 470], [1458, 726], [1037, 713]]

	world_to_p2 = get_transformation(rectangle_world, rectangle_projector)
	p2_to_world = get_transformation(rectangle_projector, rectangle_world)

	[p1projector, p1camera], [p2projector, p2camera], [p3projector, p3camera] = matches

	cam_to_p1 = get_transformation(p1camera, p1projector)
	cam_to_p3 = get_transformation(p3camera, p3projector)
	cam_to_p2 = get_transformation(p2camera, p2projector)

	p1_to_cam = get_transformation(p1projector, p1camera)
	p2_to_cam = get_transformation(p2projector, p2camera)
	p3_to_cam = get_transformation(p3projector, p3camera)

	world_to_cam = np.dot(p2_to_cam, world_to_p2)
	cam_to_world = np.dot(p2_to_world, cam_to_p2)

	world_to_p1 = np.dot(cam_to_p1, world_to_cam)
	world_to_p3 = np.dot(cam_to_p3, world_to_cam)

	p1_to_world = np.dot(cam_to_world, p1_to_cam)
	p3_to_world = np.dot(cam_to_world, p3_to_cam)

	# print p1_to_world.dot(np.asarray([[0,1024,1024,0],[768,768,0,0],[1,1,1,1]]))
	# print p2_to_world.dot(np.asarray([[1024,2048,2048,1024],[768,768,0,0],[1,1,1,1]]))
	# print p3_to_world.dot(np.asarray([[2048,3072,3072,2048],[768,768,0,0],[1,1,1,1]]))

	return [world_to_p1, world_to_p2, world_to_p3]

def main(matches = None):
	return calculate_homographies(matches)

if __name__ == '__main__':
	main()

	# roslaunch lightswarm_sim inputs.launch
	# uncomment ros_boid_world.py in ^^^
	# rosrun lightswarm_renderer renderer.py